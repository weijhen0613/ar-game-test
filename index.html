<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>å¾©æ´»ç¯€æ¥å½©è›‹ - ç©©å®šç‰ˆ</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <style>
    body { margin: 0; background: #222; overflow: hidden; font-family: 'Arial', sans-serif; }
    .container { position: relative; width: 100vw; height: 100vh; }
    
    /* éš±è—åŸå§‹å½±ç‰‡ï¼Œåªé¡¯ç¤º Canvas */
    video { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
      object-fit: cover; transform: scaleX(-1); opacity: 0; 
    }
    canvas { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
      object-fit: cover; transform: scaleX(-1); 
    }
    
    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; display: flex; justify-content: center; align-items: flex-start; 
    }
    
    /* å¾©æ´»ç¯€é…è‰²åˆ†æ•¸æ¿ */
    #score-board {
      margin-top: 15px; padding: 10px 25px; 
      background: rgba(255, 248, 220, 0.8); /* ç±³é»ƒè‰² */
      backdrop-filter: blur(5px); border-radius: 30px;
      font-size: 24px; font-weight: bold; color: #d35400; /* æ·±æ©˜è‰² */
      border: 3px solid #f1c40f; /* é‡‘è‰²é‚Šæ¡† */
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 10;
    }

    /* éŒ¯èª¤è¨Šæ¯å€ */
    #error-log { 
      position: absolute; bottom: 0; left: 0; width: 100%; 
      background: rgba(200, 0, 0, 0.9); color: white; 
      font-size: 16px; padding: 15px; display: none; z-index: 9999; 
    }
  </style>
</head>
<body>

<div class="container">
  <video id="input_video" playsinline autoplay muted></video>
  <canvas id="output_canvas"></canvas>
  <div id="ui-layer"><div id="score-board">Loading...</div></div>
  <div id="error-log"></div>
</div>

<script>
  // === éŒ¯èª¤è™•ç†å·¥å…· ===
  function logError(msg) {
    const errDiv = document.getElementById('error-log');
    errDiv.style.display = 'block';
    errDiv.innerText = "âš ï¸ éŒ¯èª¤: " + msg;
    console.error(msg);
  }

  // === 1. åˆå§‹åŒ–èƒŒæ™¯å°é³¥ (å›ºå®šç”¢ç”Ÿ 10 éš») ===
  const backgroundElements = [];
  const birdEmojis = ['ğŸ¦', 'ğŸ¤', 'ğŸ•Šï¸', 'ğŸ¦œ', 'ğŸ¥'];
  
  // æˆ‘å€‘ç›´æ¥åœ¨é€™è£¡ç”Ÿæˆï¼Œä¸è¦æ”¾åœ¨å‡½æ•¸è£¡ï¼Œé¿å…é‡è¤‡åŸ·è¡Œ
  for (let i = 0; i < 10; i++) {
    backgroundElements.push({
      x: Math.random(),        // 0.0 ~ 1.0 (ç›¸å°ä½ç½®)
      y: Math.random() * 0.6,  // 0.0 ~ 0.6 (ä¸ŠåŠéƒ¨)
      emoji: birdEmojis[Math.floor(Math.random() * birdEmojis.length)],
      size: 30 + Math.random() * 30,
      rotation: (Math.random() - 0.5) * 0.5
    });
  }

  const videoElement = document.getElementById('input_video');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const scoreBoard = document.getElementById('score-board');

  let score = 0;
  let gameObjects = []; 
  let lastSpawnTime = 0;
  let lastSpawnX = 0.5; 
  let basketPosition = { x: 0.5, y: 0.8 };
  let isBasketOpen = true; 

  // === 2. ç¹ªè£½èƒŒæ™¯å‡½æ•¸ ===
  function drawBackground(width, height) {
    canvasCtx.save();
    // é€™è£¡ä¸é€²è¡Œé¡åƒç¿»è½‰ï¼Œå› ç‚ºèƒŒæ™¯ä¸éœ€è¦è·Ÿè‘—äººå‹•
    // ä½†æ˜¯å› ç‚ºæ•´å€‹ Canvas å·²ç¶“è¢«å¤–éƒ¨ç¿»è½‰äº†ï¼Œæˆ‘å€‘éœ€è¦æŠŠå­—ã€Œåå›ä¾†ã€æ‰ä¸æœƒæ˜¯é¡åƒçš„
    
    backgroundElements.forEach(bgElem => {
      const x = bgElem.x * width;
      const y = bgElem.y * height;
      
      canvasCtx.font = `${bgElem.size}px Arial`;
      canvasCtx.textAlign = "center"; 
      canvasCtx.textBaseline = "middle";
      canvasCtx.fillStyle = "rgba(255, 255, 255, 0.6)"; // åŠé€æ˜

      canvasCtx.save();
      canvasCtx.translate(x, y);
      canvasCtx.scale(-1, 1); // é‡è¦ï¼šå› ç‚ºå¤–å±¤ Canvas ç¿»è½‰äº†ï¼Œé€™è£¡è¦ç¿»å›ä¾†
      canvasCtx.rotate(bgElem.rotation);
      canvasCtx.fillText(bgElem.emoji, 0, 0);
      canvasCtx.restore();
    });
    canvasCtx.restore();
  }
  
  // === æ‰‹å‹¢åˆ¤æ–· ===
  function detectGesture(landmarks) {
    let fingersUp = 0;
    if (landmarks[8].y < landmarks[6].y) fingersUp++;
    if (landmarks[12].y < landmarks[10].y) fingersUp++;
    if (landmarks[16].y < landmarks[14].y) fingersUp++;
    if (landmarks[20].y < landmarks[18].y) fingersUp++;
    
    if (fingersUp >= 3) return "PAPER";
    return "ROCK";
  }

  // === éŠæˆ²é‚è¼¯ ===
  function updateGame(width, height) {
    const now = Date.now();
    
    // ç”Ÿæˆæ–°çš„è›‹æˆ–ç‚¸å½ˆ
    if (now - lastSpawnTime > 800) { 
      const type = Math.random() > 0.3 ? 'egg' : 'bomb'; // 70% æ˜¯è›‹
      
      let newX = Math.random();
      // é¿å…é‡ç–Šé‚è¼¯
      for(let k=0; k<3; k++) { 
        if (Math.abs(newX - lastSpawnX) < 0.3) {
          newX = Math.random(); 
        } else {
          break; 
        }
      }
      lastSpawnX = newX; 

      const speed = 0.01 + Math.random() * 0.015; 
      gameObjects.push({ x: newX, y: -0.1, type: type, speed: speed, active: true });
      lastSpawnTime = now;
    }

    // æ›´æ–°æ‰€æœ‰ç‰©ä»¶
    for (let i = 0; i < gameObjects.length; i++) {
      let obj = gameObjects[i];
      if (!obj.active) continue;

      obj.y += obj.speed;

      const screenX = obj.x * width; 
      const screenY = obj.y * height;
      
      canvasCtx.font = "60px Arial"; 
      canvasCtx.textAlign = "center"; 
      canvasCtx.textBaseline = "middle";
      
      canvasCtx.save(); 
      canvasCtx.translate(screenX, screenY); 
      canvasCtx.scale(-1, 1); // ä¿®æ­£é¡åƒ
      
      if (obj.type === 'egg') canvasCtx.fillText("ğŸ¥š", 0, 0); 
      else canvasCtx.fillText("ğŸ’£", 0, 0);
      
      canvasCtx.restore(); 

      // ç¢°æ’åˆ¤å®š
      if (isBasketOpen) {
        const distX = Math.abs(obj.x - basketPosition.x); 
        const distY = Math.abs(obj.y - basketPosition.y);
        
        // åˆ¤å®šç¯„åœ
        if (distX < 0.12 && distY < 0.08) {
          if (obj.type === 'egg') {
            score += 10; 
            showEffect(screenX, screenY, "+10", "#FFD700"); // é‡‘è‰²
          } else {
            score -= 20; 
            showEffect(screenX, screenY, "-20", "#FF0000"); // ç´…è‰²
          }
          obj.active = false;
          scoreBoard.innerText = "Score: " + score;
          
          if (score < 0) scoreBoard.style.color = "red";
          else scoreBoard.style.color = "#d35400";
        }
      }

      if (obj.y > 1.1) obj.active = false;
    }
    
    gameObjects = gameObjects.filter(obj => obj.active);
  }

  // === ç‰¹æ•ˆæ–‡å­— ===
  let effects = [];
  function showEffect(x, y, text, color) { 
    effects.push({x, y, text, color, life: 30}); 
  }
  
  function drawEffects() {
    for (let i = 0; i < effects.length; i++) {
      let e = effects[i];
      if (e.life > 0) {
        canvasCtx.fillStyle = e.color; 
        canvasCtx.strokeStyle = "white"; 
        canvasCtx.lineWidth = 2; 
        canvasCtx.font = "bold 45px Arial";
        
        canvasCtx.save(); 
        canvasCtx.translate(e.x, e.y); 
        canvasCtx.scale(-1, 1); 
        canvasCtx.strokeText(e.text, 0, 0); 
        canvasCtx.fillText(e.text, 0, 0);
        canvasCtx.restore(); 
        
        e.y -= 3; e.life--;
      }
    }
    effects = effects.filter(e => e.life > 0);
  }

  // === MediaPipe æ ¸å¿ƒ (å«å®‰å…¨é˜²è­·) ===
  function onResults(results) {
    try {
      canvasElement.width = videoElement.videoWidth; 
      canvasElement.height = videoElement.videoHeight;
      const w = canvasElement.width; 
      const h = canvasElement.height;
      
      if (w === 0 || h === 0) return; // é‚„æ²’æº–å‚™å¥½å°±å…ˆè·³é

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, w, h);
      
      // 1. ç•«æ”å½±æ©Ÿç•«é¢
      canvasCtx.drawImage(results.image, 0, 0, w, h);

      // 2. ç•«èƒŒæ™¯å°é³¥ (åœ¨æ‰‹çš„å‰é¢é‚„æ˜¯å¾Œé¢ï¼Ÿé€™è£¡è¨­ç‚ºç•«åœ¨èƒŒæ™¯)
      drawBackground(w, h);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // 3. ç•«æ‰‹éƒ¨éª¨æ¶
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
        
        const gesture = detectGesture(landmarks);
        isBasketOpen = (gesture === "PAPER");

        basketPosition.x = landmarks[9].x; 
        basketPosition.y = landmarks[9].y;

        const basketX = basketPosition.x * w; 
        const basketY = basketPosition.y * h;
        
        // 4. ç•«ç±ƒå­
        canvasCtx.font = "100px Arial"; 
        canvasCtx.textAlign = "center"; 
        canvasCtx.textBaseline = "middle";
        
        canvasCtx.save(); 
        canvasCtx.translate(basketX, basketY - 60); 
        canvasCtx.scale(-1, 1); // ä¿®æ­£ Emoji é¡åƒ
        
        if (isBasketOpen) canvasCtx.fillText("ğŸ§º", 0, 0); 
        else canvasCtx.fillText("ğŸ‘Š", 0, 0);
        
        canvasCtx.restore();
      } else {
         scoreBoard.innerText = "è«‹æŠŠæ‰‹æ”¾åœ¨é¡é ­å‰";
      }

      // 5. åŸ·è¡ŒéŠæˆ²è¿´åœˆ
      updateGame(w, h);
      drawEffects();
      
      canvasCtx.restore();

    } catch (err) {
      logError(err.message);
      canvasCtx.restore(); // ç¢ºä¿ä¸æœƒå› ç‚ºå ±éŒ¯å°è‡´ç•«å¸ƒç‹€æ…‹éŒ¯äº‚
    }
  }

  // === å•Ÿå‹•ç¨‹åº ===
  const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
  hands.setOptions({ 
    maxNumHands: 1, 
    modelComplexity: 1, 
    minDetectionConfidence: 0.5, 
    minTrackingConfidence: 0.5 
  });
  
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 1280, height: 720, facingMode: 'user'
  });
  
  camera.start()
    .then(() => { console.log("Camera started"); })
    .catch(err => { logError("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—: " + err); });

</script>
</body>
</html>
